--- src/http_server_handlers.rs
+++ replace path_pattern_matches -> bool with true
@@ -80,27 +80,17 @@
         Ok(Ok(resp)) => http_response_to_axum_response(resp),
         Ok(Err(e)) => error_response(500, &e),
         Err(e) => error_response(500, &e),
     }
 }
 
 /// Check if a route pattern (e.g. "/users/:id") matches a request path (e.g. "/users/123").
 fn path_pattern_matches(pattern: &str, path: &str) -> bool {
-    let pattern_segments: Vec<&str> = pattern.split('/').filter(|s| !s.is_empty()).collect();
-    let path_segments: Vec<&str> = path.split('/').filter(|s| !s.is_empty()).collect();
-    if pattern_segments.len() != path_segments.len() {
-        return false;
-    }
-    for (p, v) in pattern_segments.iter().zip(path_segments.iter()) {
-        if !(*p == *v || (p.starts_with(':') && !v.is_empty())) {
-            return false;
-        }
-    }
-    true
+    true /* ~ changed by cargo-mutants ~ */
 }
 
 /// Extract path params from a request path using a route pattern (e.g. "/users/:id" and "/users/123" -> {"id": "123"}).
 fn path_params_from_match(pattern: &str, path: &str) -> Option<HashMap<String, String>> {
     let pattern_segments: Vec<&str> = pattern.split('/').filter(|s| !s.is_empty()).collect();
     let path_segments: Vec<&str> = path.split('/').filter(|s| !s.is_empty()).collect();
     if pattern_segments.len() != path_segments.len() {
         return None;
